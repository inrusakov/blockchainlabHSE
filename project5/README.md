Русаков Иван БПИ206

Address deploying the contract --> 0xb3389d620d258d1bd0Cffbd1CdD237c152218ec5

Token contract address --> 0x0cF251557d3ddB436E5cAE20B7a9a908b857A978

Ответы на вопросы:

1. Почему на этапе разработки используется локальная EVM, а не рабочая?

На этапе разработки используется локальная EVM (Ethereum Virtual Machine) вместо рабочей сети по нескольким причинам:

Безопасность: Работа с локальной EVM позволяет избежать случайного взаимодействия с реальными смарт-контрактами и аккаунтами, что может привести к потере средств или другим нежелательным последствиям.
    
Скорость разработки: Локальная EVM обеспечивает быстрое взаимодействие и тестирование, поскольку она не зависит от времени блока и скорости сети.
    
Экономия средств: Использование локальной EVM позволяет избежать затрат на газ, связанные с развертыванием и взаимодействием со смарт-контрактами в рабочей сети.
    
Управление состоянием: Локальная EVM позволяет легко управлять состоянием блокчейна, что упрощает тестирование различных сценариев и отладку.

2. С чем связана сложность проведения формальных проверок смарт-контрактов?

Сложность проведения формальных проверок смарт-контрактов связана с несккими факторами:

Непредсказуемость состояния блокчейна: Состояние блокчейна может меняться в зависимости от внешних фактор, таких как транзакции и взаимодействия с другими контрактами. Это усложняет анализ и верификацию смарт-контрактов.

Взаимодействие с другими контрактами: Смарт-контракты могут вызывать функции и взаимодействовать с другими контрактами, что создает сложные зависимости и усложняет анализ.

Тьюринг-полнота: Язы программирования смарт-контрактов, такие как Solidity, являются тьюринг-полными, что означает, что они могут выразить любой алгоритм. Это делает невозможным полное и точное предсказание поведения смарт-контракта во всех случаях.


3. Как передать eth при вызовах call и delegatecall?

Для call:

(bool success, ) = targetAddress.call{value: msg.value}("");
require(success, "Call failed");

Для delegatecall:

Функция delegatecall не позволяет напрямую передавать ETH, так как он выполняет код целевого контракта в контексте вызывающего контракта, сохраняя msg.sender и msg.value неизменными. Если нужно передать ETH вместе с вызовом delegatecall, можно сначала отправить ETH на адрес контракта, а затем использовать delegatecall для вызова функции, которая будет управлять этими средствами.
    
4. В чём заключается суть Re-Entrancy атаки?

ReEntrancy атака - это атака на смарт-контракт, при которой злоумышленник использует рекурсивный вызов функции контракта для многократного извлечения средств или манипуляции состоянием контракта. Атака происходит, когда смарт-контракт вызывает внешний контракт перед обновлением своего вутреннего состояния. Злоумышленник может создать контракт, который в свою очередь вызывает функцию исходного контракта, прежде чем его состояние будет облено, что может привести к непредвиденным последствиям, таким как кража средств или изменение состояния контракта.

# Sample Hardhat Project

This project demonstrates a basic Hardhat use case. It comes with a sample contract, a test for that contract, and a script that deploys that contract.

Try running some of the following tasks:

```shell
npx hardhat help
npx hardhat test
REPORT_GAS=true npx hardhat test
npx hardhat node
npx hardhat run scripts/deploy.js
```
